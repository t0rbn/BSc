\chapter{Implementation}
\section{Application Structure}
The application consists of two main components: the frontend that presents the user with a graphical interface and the backend that provides data and actions on it to the frontend.
The user's browser connects to a web server that acts as a reverse proxy and not only provides static resources like HTML and CSS files which resemble the frontend, but also acts as an SSL endpoint.
Requests for dynamic data and actions that are handled via the REST API provided by the backend are passed on to it, its response will then be directed through the reverse proxy to the client.
To store and read data, the backend connects to a MongoDB Database. User details are synced from the existing LDAP server which acts a central repository for personal information of all employees.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/system_architecture.png}
    \caption[Illustration: System Architecture]{The system's architecture. Created with \textit{https://cloudcraft.co}.}
    \label{fig:markovchain}
\end{figure}

\newpage
\section{MongoDB}
MongoDB\footnote{https://www.mongodb.com} is a popular non-relational NoSQL database that aims to be fast and easy to use \cite[p. 10]{MongoGuide}. To increase performance, like many NoSQL databases, it does not provide ACID\footnote{Atomicity, Consistency, Isolation, Durability} transactions which are a well-known feature of relational database management systems (RDBMS). This, however, simplifies horizontal scaling since new machines can easily be inserted into an existing cluster of database servers without the need to be in sync \cite[p. 3]{MongoGuide}.

\subsection{BSON}
\label{BSON}
In contrast to relational databases that store all data in tables, MongoDB uses a document-orient data structure saving every element in the Binary JSON\footnote{Javascript Object Notation} (BSON) format. This approach allows complex data to be stored as one object rather than having to dissect its elements and storing them in separate tables. As a consequence, retrieving an object from the database is much more efficient than it would be using an RDBMS, as the latter needs to join the tables storing the object's nested sub-objects and compose the requested element whereas MongoDB has it stored in the exact same form it is requested \cite[p. 10]{MongoGuide}.

\subsection{Data Structure}
The application stores three different object classes in the database: skills that are known to the system, persons with their individual contact data and personal skills, and sessions used to authenticate users that wish to modify their profiles. In order to instantiate the elements as java objects, Spring Data\footnote{http://projects.spring.io/spring-data/}, the framework used for database access, also stores the class name the object needs to be mapped to as a field inside of it. Furthermore, every item has the field \textit{version} which holds a version number used to resolve writing conflicts that may occur when multiple threads access the same object simultaneously.

\newpage
\subsubsection{Known Skills}
Skills known to the system consist of a unique name and a list of suggestions that themselves are expressed by a name and a total count of searches of the respective suggestion together with the skill. This list will be used to predict the next item a user is likely to enter as described in \ref{autocomplete}.
\begin{figure}[h]
\begin{lstlisting}[language=Java]
{
  "_id" : "Java",
  "_class" : "[...].skills.KnownSkill",
  "suggestions" : [
    {
      "name" : "AEM",
      "count" : 1
    }, {
      "name" : "jquery",
      "count" : 1
    }
  ],
  "version" : NumberLong(3)
}
\end{lstlisting}
\caption[Data Structure: Skill]{Data structure of a skill stored in the database}
\end{figure}

\subsubsection{Sessions}
Sessions are used to authenticate users that wish to modify their personal profile. The client has to authenticate the user with their credentials; if this is successful, a new session holding a unique ID, the point of time it will expire, and the ID of the authenticated user, will be created and stored in the database.

\begin{figure}[h]
\begin{lstlisting}[language=Java]
{
	"_id" : "87163f310f124830bac677fe31484262",
	"_class" : "com.sinnerschrader.skillwill.session.Session",
	"username" : "foobar",
	"expireDate" : ISODate("2017-01-09T08:36:40.128Z"),
	"version" : NumberLong(1)
}
\end{lstlisting}
\caption[Data Structure: Session]{Data structure of a session stored in the DB}
\end{figure}
\newpage

\subsubsection{Persons}
\label{db:person}
The documents that represent persons contain the respective person's id\footnote{Each employee gets assigned an internal ID (\textit{Benutzerk√ºrzel}) that is globally used to uniquely identify a person.}, their personal data like first and last name, telephone number, e-mail address, office location, job title\footnote{The job title data is not maintained consistently in the LDAP, so that, unfortunately, it is not suitable to be used in the person search.}, and a list of the person's skills. Each of those skills consists of a name, a level of skill and a level of will.
\begin{figure}[h]
\begin{lstlisting}[language=Java]
{
  "_id" : "foobar",
  "_class" : "com.sinnerschrader.skillwill.domain.person.Person",
  "skills" : [
    {
      "_id" : ".NET",
      "skillLevel" : 1,
      "willLevel" : 2
    },{
      "_id" : "Scrum",
      "skillLevel" : 3,
      "willLevel" : 1
    }
  ],
  "version" : NumberLong(1),
  "ldapDetails" : {
    "firstName" : "Fooberius",
    "lastName" : "Bartels",
    "mail" : "foobar@mail.org",
    "phone" : "+49 12 345678 901",
    "location" : "Hamburg",
    "title" : "Development"
  }
}
\end{lstlisting}
\caption[Data Structure: Person]{Data structure of a person stored in the DB}
\end{figure}

\newpage



\subsection{Queries}
As shown in \ref{BSON}, the document based data structure of MongoDB allows the database to efficiently perform complex requests. Furthermore, it provides simple and straightforward search queries to retrieve objects based on their attributes. For example, getting all users who offer the skill \textit{Ruby} from the collection \textit{person} can be done with this straightforward query:
\begin{figure}[h]
\begin{lstlisting}[language=Java]
db.person.find({ "skills._id" : "Ruby" })
\end{lstlisting}
\caption[Code: Example Database Query]{MongoDB query to retrieve all users with the skill \textit{Ruby}}
\end{figure}

\section{LDAP}
SinnerSchrader runs an LDAP server which acts as a centralized source of personal information of all employees to provide all internal tools with data. The application connects to this server in order to retrieve contact information to display in users' profiles. In comparison with having the users to enter their data manually, this method has the benefit that the users' data will be kept in sync across all internal services, and that it reduces the effort a user has to spend to create their profile.

\section{Reverse Proxy}
Between the client and the backend, an intermediary web server that acts as a reverse proxy is switched in. Its main purpose is the distinguishing between requests for static files, like HTML and CSS content that will be directly delivered by said server, and API calls that are redirected to the backend. This increases the system's security by protecting the backend server's identity and presenting an additional defense layer \cite{NGINX}. Furthermore, this server can handle SSL encryption between the application and the client, and, if multiple backend servers are needed, balance the workload between them while presenting one uniform service to the outside.

\section{API}
To exchange data between the backend and the frontend, a \textit{Representational State Transfer} (REST) API is provided by the backend. Its endpoints are called by the fronted code to either request data or to command the backend to perform modifying operations on it.
The used HTTP method is the main indicator of the action to perform: \textit{GET} is used to retrieve data, \textit{POST} to insert new elements, \textit{PUT} to modify existing ones and \textit{DELETE} to remove them. The URLs of the individual action express the entity on which the action will be performed. All API endpoints are listed in table \ref{swaggertable}.

\begin{table}[p]
\centering
\rotatebox{-90}{
  \begin{tabular}{l|l|l|l|l}
  URL & HTTP Method & Non-URL Parameters & Return Statuses & Comment\\
  \hline
  /login               & POST   & username, password                          & 200, 401, 500           & Try to login a user;\\ & & & & returns session key\\ \hline
  /logout              & POST   & session                                     & 200, 401, 500           & Logout a session\\ \hline
  /skills              & GET    & search                                      & 200, 500                & Search for autocompletion;\\ & & & & returns all skills if search is empty\\ \hline
  /skills              & POST   & name                                        & 200, 400, 401, 500      & Add new skill with\\ & & & & the given name\\ \hline
  /skills/next         & GET    & search                                      & 200, 400, 500           & Suggest a skill based on\\ & & & & the comma separated list of\\ & & & &   skills (parameter: search)\\ \hline
  /skills/\{skill\}      & DELETE &                                             & 200, 400, 401, 404, 500 & Remove the skill\\ & & & &  with the given name\\ \hline
  /skills/\{skill\}      & PUT    & name                                        & 200, 400, 401, 404, 500 & Rename the skill\\
	\hline
	/users               & GET    & skills, location                            & 200, 400, 500           & Get all users\\ & & & &  matching the searched\\ & & & & skills in the given location\\ & & & & (parameters may be empty)\\ \hline
  /users/\{user\}        & GET    &                                             & 200, 404, 500           & Return the specified user\\ \hline
  /users/\{user\}/skills & POST   & session, skill, skill\_level, will\_level & 200, 400, 401, 404, 500 & Create new skill/modifiy existing\\ & & & & personal skill\\ \hline
  /users/\{user\}/skills & DELETE & session, skill                              & 200, 400, 401, 404, 501 & Remove the skill\\ & & & & from the users profile\\
  \end{tabular}
  }
\caption[API Endpoints]{All API endpoints provided by the backend}
\label{swaggertable}
\end{table}
\newpage

\subsection{API Responses}
The API returns data in the JSON format, which is one of the two de-facto standards for data exchange on the web\footnote{The other one is \textit{XML} used by the \textit{Simple Object Access Protocol}} because it is part of the Javascript (JS) language \cite[p. 37]{json}. Approximately 94\% of all websites use JS \cite{jsmarket}; since JSON directly represents JS objects and is both easy to parse and human-readable, it became the leading data format for web applications.
For every HTTP request, the backend will return a JSON response, notwithstanding the request may not demand data to be returned. In this case, the response will contain status information about the success of the requested action.

\begin{figure}[h]
\begin{lstlisting}[language=Java]
{
	"id" : "foobar",
	"firstName" : "Fooberius",
	"lastName" : "Bartels",
	"mail" : "foobar@mail.org",
	"phone" : "+49 12 345678 901",
	"location" : "Hamburg",
	"title" : "Development",
	"skills" : [
		{
			"name" : ".NET",
			"skillLevel" : 1,
			"willLevel" : 2
		}, {
			"name" : "Scrum",
			"skillLevel" : 3,
			"willLevel" : 1
		}
	]
}
\end{lstlisting}
\caption[Data Structure: Person API Response]{Example JSON response by the API for the request \textit{/users/foobar}. For comparison, the corresponding database entry is shown in \ref{db:person}.}
\end{figure}


\begin{figure}[h]
\begin{lstlisting}[language=Java]
{
	"message" : "logout successful"
}
\end{lstlisting}
\caption[Data Structure: Status API Response]{Example JSON response for a request that does not demand any data.}
\end{figure}


\section{Backend}
\label{impl:be}
The backend component is implemented in Java 8\footnote{https://go.java/} using the Spring Boot framework\footnote{https://projects.spring.io/spring-boot/}. Maven\footnote{https://maven.apache.org/what-is-maven.html} is employed to manage the build process and run unit and integration tests.

\section{Architecture}
The software architecture consists of three main categories of classes: services handling data manipulation and filtering that hold the business logic, repository objects that wrap the database operations into easy to use handlers, and domain specific data types. Additionally, numerous helper classes like custom exception types, comparators, and general utilities are implemented.
\begin{figure}[!h]
    \centering
    \includegraphics[height=0.55\textheight]{images/uml.png}
    \caption[Diagram: Backend Classes]{UML class diagram of the backend to illustrate its dimensions.}
    \label{fig:markovchain}
\end{figure}
\newpage

\subsection{Spring Boot}
\textit{Spring Boot} is a highly sophisticated web framework that provides numerous features to create web applications including, but not limited to, annotations to expose java methods as HTTP request endpoints, an embedded webserver to run the application on, a modular design to extend its features, and dependency injection. It comes to use because its credo to provide default configurations where possible and thus reduce the need to write infrastructure code simplifies the applications' structure \cite[p. 6]{SpringGuide}.
For example, a controller that returns a static response can be created using two annotations:
\textit{@Controller} to make Spring Boot identify the class as a resource that will listen to HTTP calls, and \textit{@Request} to specify the URL and HTTP method to use. Unlike most other web frameworks, Spring Boot does not require any more configuration or dispatching classes.

\begin{figure}[h]
\begin{lstlisting}[language=Java]
@Controller
public class HTCPCPImpl {

	@RequestMapping(path = "/coffee", method = RequestMethod.GET)
	public ResponseEntity<String> coffee() {
		StatusJSON json = new StatusJSON("I'm a teapot \u2615");
		return new ResponseEntity<String>(
      json.toString(),
      HttpStatus.I_AM_A_TEAPOT
    );
	}

}
\end{lstlisting}
\caption[Code: Example Controller]{Example controller using Spring Boot}
\end{figure}

\newpage
\subsection{Spring Data Repositories}
\textit{Spring Data}\footnote{http://projects.spring.io/spring-data/} is a module for Spring Boot that streamlines the way elements can be accessed from a database.
The components mainly used in this application are CRUD\footnote{Create, Read, Update, Delete} repository objects that enclose the database connections and serve
simple java methods as an interface. To create such a repository, a java interface defining the stored data type and custom database queries has to be constructed.
No actual implementation of the interface has to be created since it will be generated automatically by Spring Data.
The parameters needed to connect to the database have to be configured in any source of properties known to Spring Boot, e.g. in \textit{src/main/resources/application.properties}.

\begin{figure}[h]
\begin{lstlisting}[language=Java]
public interface PersonRepository
		extends MongoRepository<Person, String> {

	Person findById(String id);

	@Query("{ skills._id : ?0 }")
	List<Person> findBySkill(String skillName);

}
\end{lstlisting}
\caption[Code: Example Repository Interface]{Example for a repository interface managing person objects stored in the database.}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}[language=Java]
spring.data.mongodb.host=127.0.0.1
spring.data.mongodb.port=27017
spring.datasource.driverClassName=com.mongodb.Mongo
\end{lstlisting}
\caption[Code: Spring Data Config]{All configuration parameters needed to run Spring Data}
\end{figure}

\subsection{LDAP Connection}
To connect to the LDAP server, the \textit{unboundid} library\footnote{https://www.ldap.com/unboundid-ldap-sdk-for-java} is used in the class \textit{LdapService}, It provides methods to open a TCP connection to the server, make requests, and parse the server's response. The connection to the LDAP server will be kept alive and is reused for all operations, so that the effort to open a new connection is eliminated.

\begin{figure}[H]
\begin{lstlisting}[language=Java]
@Service
@Scope("singleton")
@EnableRetry
public class LdapService {

	private static Logger logger =
		LoggerFactory.getLogger(LdapService.class);

	// [fields not used in this example]

	private static LDAPConnection ldapConnection;

	@Autowired
	private PersonRepository personRepo;

	// [methods for user sync and connection handling]

	public boolean canAuthenticate(String username,
			String password) {
		try {
			BindRequest bindRequest = new SimpleBindRequest(
				"uid=" + username + "," + ldapBaseDN, password);
			BindResult bindResult =
				ldapConnection.bind(bindRequest);
			if (bindResult.getResultCode()
					.equals(ResultCode.SUCCESS)) {
				return true;
			}
			return false;
		} catch (LDAPBindException e) {
			return false;
		} catch (LDAPException e) {
			logger.error("Failed to authenticate: LDAP error");
		}
		return false;
	}

}
\end{lstlisting}
\caption[Code: LDAP User Authentication]{LDAP user authentication using the unboundid library. Note: parts of the code have been removed to simplify this example.}
\end{figure}


\subsection{Swagger}
\textit{Swagger}\footnote{http://swagger.io/} is an open source framework for creating documentations of REST APIs.
Its annotation based java integration is heavily used to generate an interactive overview of the API endpoints provided by the
backend. This overview is automatically served by spring boot and contains a list of all URLs to make requests to, HTTP response codes to expect, the content type of the response and a built in form to make example requests. The main advantage of this approach is that the code and its documentation are located at the very same place and that parts of the documentation are automatically generated, so that both are maintained synchronously, thus avoiding the documentation differing from the implementation.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/swagger_ui.png}
    \caption[Screenshot: Swagger Interactive Documentation]{Interactive API documentation generated by Swagger}
    \label{fig:markovchain}
\end{figure}

\subsection{Testing}
As a part of the build process, automatic tests are run using the \textit{JUnit}\footnote{http://junit.org} framework. Two types of tests are employed to ensure the proper working of the software: unit tests that validate isolated segments (java classes), and integration tests that simulate calls to the controllers and test the
interplay of the individual components.

\begin{figure}[h]
\begin{lstlisting}[language=Java]
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest
public class KnownSkillSuggestionComparatorTest {

	@Test
	public void testNoneStarts() {
		KnownSkill a = new KnownSkill("Wurstwasser");
		KnownSkill b = new KnownSkill("foo");

		List<KnownSkill> toSort = new ArrayList<KnownSkill>();
		toSort.add(a);
		toSort.add(b);
		toSort.sort(new KnownSkillSuggestionComparator("42"));

		assertEquals(a, toSort.get(0));
		assertEquals(b, toSort.get(1));
	}

	@Test
	public void bothStart() {
		KnownSkill a = new KnownSkill("foobar");
		KnownSkill b = new KnownSkill("foowurst");

		List<KnownSkill> toSort = new ArrayList<KnownSkill>();
		toSort.add(a);
		toSort.add(b);
		toSort.sort(new KnownSkillSuggestionComparator("foo"));

		assertEquals(a, toSort.get(0));
		assertEquals(b, toSort.get(1));
	}

}
\end{lstlisting}
\caption[Code: Example Unit Test]{Example unit test using JUnit}
\end{figure}


\subsubsection{Embedded Services}
During the integration test phase, external services like LDAP and a database have to be accessed in order to ensure the proper working of the interfaces connecting to them. Using the real services, however, is not an option as it cannot be assumed that the machine that runs the tests has a connection to them, and because the tests have to take control over the state of the services. To solve this, an LDAP server and a MongoDB are embedded into the application and will be used during testing.
The embedded database is the MongoDB implementation by \textit{flapdoodle}\footnote{https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo}, which has the advantage of being effortlessly deployed by importing it; all further configuration and setup happen automatically.
To embed an LDAP service, the \textit{unboundid} library is used.

\section{License}
The software is licensed under the MIT license \cite{license} which is considered one of the most popular open source licenses, mainly because it grants a high level of freedom to modify and use the software under the sole condition that a copy of the original license is distributed algonside the software.

\begin{quote}
Copyright 2017 SinnerSchrader Deutschland GmbH

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\end{quote}\cite{license}
